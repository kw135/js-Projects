/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/app.ts":
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.app = void 0;\nexports.app = {\n    sizeX: 16,\n    sizeY: 20,\n    sizeY2: 40,\n    sizeX2: 29,\n    selectedTiles: [],\n    previouslySelected: [],\n    isControlHeld: false,\n    isCut: false,\n    mapTiles: [],\n    coppiedTiles: [],\n    clearSelection: () => {\n        exports.app.previouslySelected.forEach(id => {\n            const prevTile = document.getElementById(id.toString());\n            if (prevTile) {\n                prevTile.className = \"tile\";\n            }\n        });\n    }\n};\n\n\n//# sourceURL=webpack://map-generator/./src/app.ts?");

/***/ }),

/***/ "./src/imgTile.ts":
/*!************************!*\
  !*** ./src/imgTile.ts ***!
  \************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImgTile = void 0;\nconst app_1 = __webpack_require__(/*! ./app */ \"./src/app.ts\");\nconst tileoperations_1 = __importDefault(__webpack_require__(/*! ./tileoperations */ \"./src/tileoperations.ts\"));\nclass ImgTile {\n    constructor(id, x, y) {\n        this.id = id;\n        this.x = x;\n        this.y = y;\n        this.element = document.createElement(\"canvas\");\n        this.element.className = \"square\";\n        this.element.style.backgroundPositionX = -x * 48 - 1 + \"px\";\n        this.element.style.backgroundPositionY = -y * 48 - 1 + \"px\";\n        this.element.setAttribute(\"id\", `item${id}`);\n        this.element.onclick = () => this.handleClick();\n    }\n    handleClick() {\n        // console.log(app.selectedTiles, app.previouslySelected, \"item\");\n        const checked = document.getElementById(\"auto\");\n        const isChecked = checked.checked;\n        if (app_1.app.selectedTiles.length !== 0) {\n            const nextId = Math.max(...app_1.app.selectedTiles) + 1;\n            app_1.app.previouslySelected = app_1.app.selectedTiles;\n            app_1.app.selectedTiles.forEach((id) => {\n                const tile = document.getElementById(id.toString());\n                if (tile) {\n                    tile.className = \"tile selected\";\n                    tile.style.backgroundImage = \"url('../img/sprites.png')\";\n                    tile.style.backgroundPosition = this.element.style.backgroundPosition;\n                    if (!app_1.app.isControlHeld) {\n                        app_1.app.selectedTiles = [];\n                    }\n                    if (isChecked)\n                        app_1.app.selectedTiles.push(nextId);\n                    tile.className = \"tile\";\n                }\n            });\n            if (app_1.app.previouslySelected.length !== 0)\n                tileoperations_1.default.saveState();\n        }\n    }\n}\nexports.ImgTile = ImgTile;\n\n\n//# sourceURL=webpack://map-generator/./src/imgTile.ts?");

/***/ }),

/***/ "./src/load.ts":
/*!*********************!*\
  !*** ./src/load.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.loadFromFile = void 0;\nconst app_1 = __webpack_require__(/*! ./app */ \"./src/app.ts\");\nconst loadFromFile = () => {\n    const fileInput = document.createElement(\"input\");\n    fileInput.type = \"file\";\n    fileInput.click();\n    fileInput.addEventListener(\"change\", function (e) {\n        load(e.target);\n    });\n};\nexports.loadFromFile = loadFromFile;\nconst load = (files) => {\n    console.log(files.files);\n    const file = files.files[0];\n    const reader = new FileReader();\n    reader.readAsText(file);\n    reader.onload = function () {\n        const data = reader.result;\n        const dataArray = data.split(\",\");\n        app_1.app.mapTiles.forEach((tile, i) => {\n            tile.element.style.backgroundPosition = \"\";\n            tile.element.style.backgroundImage = \"\";\n            if (dataArray[i] != \"0px 0px\") {\n                tile.element.style.backgroundPosition = dataArray[i];\n                tile.element.style.backgroundImage = \"url('../img/sprites.png')\";\n            }\n        });\n    };\n};\n\n\n//# sourceURL=webpack://map-generator/./src/load.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst app_1 = __webpack_require__(/*! ./app */ \"./src/app.ts\");\nconst mapTile_1 = __webpack_require__(/*! ./mapTile */ \"./src/mapTile.ts\");\nconst imgTile_1 = __webpack_require__(/*! ./imgTile */ \"./src/imgTile.ts\");\nconst save_1 = __webpack_require__(/*! ./save */ \"./src/save.ts\");\nconst load_1 = __webpack_require__(/*! ./load */ \"./src/load.ts\");\nconst tileoperations_1 = __importDefault(__webpack_require__(/*! ./tileoperations */ \"./src/tileoperations.ts\"));\nconst setUpListeners_1 = __webpack_require__(/*! ./setUpListeners */ \"./src/setUpListeners.ts\");\nwindow.addEventListener(\"load\", function () {\n    const dialog = document.getElementById(\"contextMenu\");\n    const functions = [() => { tileoperations_1.default.undo(); dialog.close(); }, () => { tileoperations_1.default.redo(); dialog.close(); }, () => { tileoperations_1.default.cut(); dialog.close(); }, () => { tileoperations_1.default.copy(); dialog.close(); }, () => { tileoperations_1.default.paste(); dialog.close(); }, () => { tileoperations_1.default.delete(); dialog.close(); }, () => { (0, save_1.save)(\"map\"); dialog.close(); }, () => { (0, load_1.loadFromFile)(); dialog.close(); }];\n    for (let i = 0; i < dialog.children.length; i++) {\n        dialog.children[i].addEventListener(\"click\", functions[i]);\n    }\n    const itemsCanvas = document.getElementById(\"itemsCanvas\");\n    let count = 0;\n    for (let y = 0; y < app_1.app.sizeY; y++) {\n        for (let x = 0; x < app_1.app.sizeX; x++) {\n            const imgTile = new imgTile_1.ImgTile(count, x, y);\n            itemsCanvas?.appendChild(imgTile.element);\n            count++;\n        }\n    }\n    const mainCanvas = document.getElementById(\"mainCanvas\");\n    count = 0;\n    for (let y = 0; y < app_1.app.sizeY2; y++) {\n        for (let x = 0; x < app_1.app.sizeX2; x++) {\n            const mapTile = new mapTile_1.MapTile(count, x, y);\n            app_1.app.mapTiles.push(mapTile);\n            mainCanvas?.appendChild(mapTile.element);\n            mapTile.updatePosition();\n            count++;\n        }\n    }\n    (0, setUpListeners_1.setupKeyListeners)();\n    window.addEventListener(\"contextmenu\", function (e) {\n        e.preventDefault();\n        dialog.style.left = (e.pageX) + \"px\";\n        dialog.style.top = (e.pageY) + \"px\";\n        dialog.showModal();\n        window.addEventListener(\"click\", function () {\n            dialog.close();\n        });\n    });\n    mainCanvas?.addEventListener(\"mousedown\", function (f) {\n        const startingPoint = {\n            x: f.clientX + mainCanvas.scrollLeft,\n            y: f.clientY + mainCanvas.scrollTop\n        };\n        const handleMouseMove = (e) => {\n            if (!app_1.app.isControlHeld) {\n                app_1.app.selectedTiles.forEach(id => {\n                    const tile = document.getElementById(id.toString());\n                    if (tile)\n                        tile.className = \"tile\";\n                });\n                app_1.app.selectedTiles = [];\n            }\n            const div = document.getElementById(\"yellow\") || document.createElement(\"div\");\n            if (!div.id) {\n                div.setAttribute(\"id\", \"yellow\");\n                div.style.backgroundColor = \"rgba(255,255,0,0.5)\";\n                div.style.position = \"absolute\";\n                div.style.pointerEvents = \"none\";\n                div.style.zIndex = \"1000\";\n                mainCanvas.appendChild(div);\n            }\n            const scrollX = mainCanvas.scrollLeft;\n            const scrollY = mainCanvas.scrollTop;\n            const currentX = e.clientX + scrollX;\n            const currentY = e.clientY + scrollY;\n            const left = Math.min(startingPoint.x, currentX);\n            const top = Math.min(startingPoint.y, currentY);\n            const width = Math.abs(currentX - startingPoint.x);\n            const height = Math.abs(currentY - startingPoint.y);\n            div.style.left = `${left - scrollX}px`;\n            div.style.top = `${top - scrollY}px`;\n            div.style.width = `${width}px`;\n            div.style.height = `${height}px`;\n            app_1.app.mapTiles.forEach(tile => {\n                const tileRect = {\n                    left: tile.position.left,\n                    top: tile.position.top,\n                    right: tile.position.left + tile.position.width,\n                    bottom: tile.position.top + tile.position.height\n                };\n                const isIntersecting = tileRect.right > left &&\n                    tileRect.left < left + width &&\n                    tileRect.bottom > top &&\n                    tileRect.top < top + height;\n                if (isIntersecting) {\n                    if (!app_1.app.selectedTiles.includes(tile.id)) {\n                        tile.element.className = \"tile selected\";\n                        app_1.app.selectedTiles.push(tile.id);\n                    }\n                }\n                else if (!app_1.app.isControlHeld) {\n                    const index = app_1.app.selectedTiles.indexOf(tile.id);\n                    if (index > -1) {\n                        app_1.app.selectedTiles.splice(index, 1);\n                        tile.element.className = \"tile\";\n                    }\n                }\n            });\n        };\n        const cleanup = () => {\n            const div = document.getElementById(\"yellow\");\n            if (div)\n                div.remove();\n            mainCanvas.removeEventListener(\"mousemove\", handleMouseMove);\n            mainCanvas.removeEventListener(\"scroll\", handleMouseMove);\n            mainCanvas.removeEventListener(\"mouseleave\", cleanup);\n            mainCanvas.removeEventListener(\"mouseup\", cleanup);\n        };\n        mainCanvas.addEventListener(\"mousemove\", handleMouseMove);\n        mainCanvas.addEventListener(\"scroll\", handleMouseMove);\n        mainCanvas.addEventListener(\"mouseleave\", cleanup);\n        mainCanvas.addEventListener(\"mouseup\", cleanup);\n    });\n});\n\n\n//# sourceURL=webpack://map-generator/./src/main.ts?");

/***/ }),

/***/ "./src/mapTile.ts":
/*!************************!*\
  !*** ./src/mapTile.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MapTile = void 0;\nconst app_1 = __webpack_require__(/*! ./app */ \"./src/app.ts\");\nclass MapTile {\n    constructor(id, x, y) {\n        this.id = id;\n        this.x = x;\n        this.y = y;\n        this.element = document.createElement(\"canvas\");\n        this.element.className = \"tile\";\n        this.position = this.element.getBoundingClientRect();\n        this.element.setAttribute(\"id\", id.toString());\n        this.element.onclick = (e) => this.handleClick(e);\n    }\n    handleClick(e) {\n        app_1.app.selectedTiles.sort();\n        if (!app_1.app.isControlHeld) {\n            app_1.app.previouslySelected = app_1.app.selectedTiles;\n            app_1.app.selectedTiles = [];\n        }\n        this.element.className = \"tile selected\";\n        if (app_1.app.selectedTiles.includes(this.id)) {\n            app_1.app.selectedTiles.splice(app_1.app.selectedTiles.indexOf(this.id), 1);\n            this.element.className = \"tile\";\n        }\n        else {\n            app_1.app.selectedTiles.push(this.id);\n        }\n        app_1.app.clearSelection();\n    }\n    updatePosition() {\n        this.position = this.element.getBoundingClientRect();\n    }\n}\nexports.MapTile = MapTile;\n\n\n//# sourceURL=webpack://map-generator/./src/mapTile.ts?");

/***/ }),

/***/ "./src/save.ts":
/*!*********************!*\
  !*** ./src/save.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.save = void 0;\nconst app_1 = __webpack_require__(/*! ./app */ \"./src/app.ts\");\nconst save = (filename) => {\n    const data = [];\n    app_1.app.mapTiles.forEach(tile => {\n        const position = tile.element.style.backgroundPosition == \"\" ? \"0px 0px,\" : `${tile.element.style.backgroundPosition},`;\n        data.push(position);\n    });\n    const blob = new Blob(data, { type: \"text/plain\" });\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement(\"a\");\n    link.href = url;\n    link.download = filename;\n    link.click();\n    setTimeout(() => {\n        URL.revokeObjectURL(url);\n    }, 0);\n};\nexports.save = save;\n\n\n//# sourceURL=webpack://map-generator/./src/save.ts?");

/***/ }),

/***/ "./src/setUpListeners.ts":
/*!*******************************!*\
  !*** ./src/setUpListeners.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setupKeyListeners = void 0;\nconst app_1 = __webpack_require__(/*! ./app */ \"./src/app.ts\");\nconst tileoperations_1 = __importDefault(__webpack_require__(/*! ./tileoperations */ \"./src/tileoperations.ts\"));\nconst setupKeyListeners = () => {\n    window.addEventListener(\"keydown\", (e) => {\n        if (app_1.app.selectedTiles) {\n            console.log(e.key);\n            switch (e.key) {\n                case \"Delete\":\n                    tileoperations_1.default.delete();\n                    break;\n                case \"Meta\":\n                case \"Control\":\n                    app_1.app.isControlHeld = true;\n                    break;\n                case \"c\":\n                    if (app_1.app.isControlHeld)\n                        tileoperations_1.default.copy();\n                    break;\n                case \"v\":\n                    if (app_1.app.isControlHeld)\n                        tileoperations_1.default.paste();\n                    break;\n                case \"x\":\n                    if (app_1.app.isControlHeld)\n                        tileoperations_1.default.cut();\n                    break;\n                case \"z\":\n                    if (app_1.app.isControlHeld)\n                        tileoperations_1.default.undo();\n                    break;\n                case \"y\":\n                    if (app_1.app.isControlHeld)\n                        tileoperations_1.default.redo();\n                    break;\n                case \"s\":\n                    e.preventDefault();\n                    if (app_1.app.isControlHeld)\n                        tileoperations_1.default.saveMap(e);\n                    break;\n                case \"l\":\n                    if (app_1.app.isControlHeld)\n                        tileoperations_1.default.loadMap();\n                    break;\n                default:\n                    break;\n            }\n        }\n    });\n    window.addEventListener(\"keyup\", (e) => {\n        switch (e.key) {\n            case \"Meta\":\n            case \"Control\":\n                app_1.app.isControlHeld = false;\n                break;\n            default:\n                break;\n        }\n    });\n};\nexports.setupKeyListeners = setupKeyListeners;\n\n\n//# sourceURL=webpack://map-generator/./src/setUpListeners.ts?");

/***/ }),

/***/ "./src/tileoperations.ts":
/*!*******************************!*\
  !*** ./src/tileoperations.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst app_1 = __webpack_require__(/*! ./app */ \"./src/app.ts\");\nconst save_1 = __webpack_require__(/*! ./save */ \"./src/save.ts\");\nconst load_1 = __webpack_require__(/*! ./load */ \"./src/load.ts\");\nconst tileOperations = {\n    history: [],\n    currentState: -1,\n    saveState() {\n        if (this.currentState < this.history.length - 1) {\n            this.history = this.history.slice(0, this.currentState + 1);\n        }\n        const tilesState = app_1.app.mapTiles\n            .filter(tile => tile.element.style.backgroundImage || app_1.app.selectedTiles.includes(tile.id))\n            .map(tile => ({\n            id: tile.id.toString(),\n            background: tile.element.style.backgroundPosition,\n            className: tile.element.className\n        }));\n        this.history.push({\n            tiles: tilesState,\n        });\n        this.currentState = this.history.length - 1;\n        console.log(this.history, \"asd\", this.currentState);\n    },\n    applyState(stateIndex) {\n        if (stateIndex <= -2 || stateIndex >= this.history.length)\n            return;\n        const state = this.history[stateIndex];\n        app_1.app.mapTiles.forEach(tile => {\n            tile.element.className = \"tile\";\n            tile.element.style.backgroundImage = \"\";\n            tile.element.style.backgroundPosition = \"\";\n        });\n        if (stateIndex !== -1) {\n            state.tiles.forEach((tileState) => {\n                const tile = document.getElementById(tileState.id);\n                if (tile) {\n                    if (tileState.background !== \"\")\n                        tile.style.backgroundImage = \"url('../img/sprites.png')\";\n                    tile.className = tileState.className;\n                    tile.style.backgroundPosition = tileState.background;\n                }\n            });\n        }\n        this.currentState = stateIndex;\n    },\n    delete() {\n        app_1.app.selectedTiles.forEach(id => {\n            const tile = document.getElementById(id.toString());\n            if (tile) {\n                tile.className = \"tile\";\n                tile.style.backgroundImage = \"\";\n                tile.style.backgroundPosition = \"\";\n            }\n        });\n        if (!app_1.app.isCut)\n            this.saveState();\n        app_1.app.selectedTiles = [];\n    },\n    copy() {\n        app_1.app.coppiedTiles = [];\n        app_1.app.selectedTiles.forEach(id => {\n            const tile = document.getElementById(id.toString());\n            app_1.app.coppiedTiles.push({\n                id: id.toString(),\n                background: tile.style.backgroundPosition,\n                rect: tile.getBoundingClientRect()\n            });\n        });\n        app_1.app.previouslySelected = app_1.app.selectedTiles;\n        app_1.app.clearSelection();\n        if (app_1.app.isCut) {\n            this.delete();\n            app_1.app.isCut = false;\n        }\n        app_1.app.selectedTiles = [];\n    },\n    paste() {\n        if (app_1.app.coppiedTiles.length !== 0) {\n            const firstTile = app_1.app.coppiedTiles[0];\n            const previewContainer = document.createElement(\"div\");\n            previewContainer.className = \"copiedDiv\";\n            const closestTile = (targetX, targetY) => {\n                return app_1.app.mapTiles.reduce((prev, current) => {\n                    const currentRect = current.element.getBoundingClientRect();\n                    const prevRect = prev.element.getBoundingClientRect();\n                    const currentDist = Math.sqrt(Math.pow(targetX - currentRect.left, 2) +\n                        Math.pow(targetY - currentRect.top, 2));\n                    const prevDist = Math.sqrt(Math.pow(targetX - prevRect.left, 2) +\n                        Math.pow(targetY - prevRect.top, 2));\n                    return currentDist <= prevDist ? current : prev;\n                });\n            };\n            let left = 0;\n            let top = 0;\n            app_1.app.coppiedTiles.forEach(({ background }, index) => {\n                const originalRect = app_1.app.coppiedTiles[index].rect;\n                const newTile = document.createElement(\"div\");\n                newTile.className = \"tile\";\n                newTile.style.border = \"2px solid green\";\n                if (background !== \"\")\n                    newTile.style.backgroundImage = \"url('../img/sprites.png')\";\n                newTile.style.backgroundPosition = background;\n                newTile.style.position = \"absolute\";\n                const offsetX = originalRect.left - firstTile.rect.left;\n                const offsetY = originalRect.top - firstTile.rect.top;\n                top = originalRect.top;\n                left = originalRect.left;\n                newTile.style.left = `${offsetX}px`;\n                newTile.style.top = `${offsetY}px`;\n                previewContainer.appendChild(newTile);\n            });\n            previewContainer.style.left = left + \"px\";\n            previewContainer.style.top = top + \"px\";\n            document.body.appendChild(previewContainer);\n            const moveHandler = (e) => {\n                const finalX = e.pageX;\n                const finalY = e.pageY;\n                const nearestTile = closestTile(finalX, finalY);\n                const tileRect = nearestTile.element.getBoundingClientRect();\n                previewContainer.style.left = `${tileRect.left + window.scrollX - 3}px`;\n                previewContainer.style.top = `${tileRect.top + window.scrollY - 2}px`;\n            };\n            const upHandler = (e) => {\n                document.removeEventListener(\"mousemove\", moveHandler);\n                document.removeEventListener(\"mouseup\", upHandler);\n                const finalX = e.pageX;\n                const finalY = e.pageY;\n                app_1.app.coppiedTiles.forEach(({ background }, index) => {\n                    const originalRect = app_1.app.coppiedTiles[index].rect;\n                    if (!originalRect)\n                        return;\n                    const offsetX = originalRect.left - firstTile.rect.left;\n                    const offsetY = originalRect.top - firstTile.rect.top;\n                    const targetX = finalX + offsetX;\n                    const targetY = finalY + offsetY;\n                    const nearestTile = closestTile(targetX, targetY);\n                    nearestTile.element.style.backgroundImage = \"\";\n                    if (background !== \"\")\n                        nearestTile.element.style.backgroundImage = \"url('../img/sprites.png')\";\n                    nearestTile.element.style.backgroundPosition = background;\n                    nearestTile.element.className = \"tile selected\";\n                    if (!app_1.app.selectedTiles.includes(nearestTile.id)) {\n                        app_1.app.selectedTiles.push(nearestTile.id);\n                    }\n                });\n                previewContainer.remove();\n            };\n            this.saveState();\n            document.addEventListener(\"mousemove\", moveHandler);\n            document.addEventListener(\"mouseup\", upHandler);\n        }\n    },\n    cut() {\n        app_1.app.isCut = true;\n        this.copy();\n    },\n    undo() {\n        const index = this.currentState - 1;\n        if (index == -1) {\n            this.applyState(-1);\n        }\n        else {\n            this.applyState(index);\n        }\n    },\n    redo() {\n        if (this.currentState < this.history.length - 1) {\n            this.applyState(this.currentState + 1);\n        }\n    },\n    saveMap(e) {\n        e.preventDefault();\n        (0, save_1.save)(\"Map\");\n    },\n    loadMap() {\n        (0, load_1.loadFromFile)();\n        this.saveState();\n    }\n};\nexports[\"default\"] = tileOperations;\n\n\n//# sourceURL=webpack://map-generator/./src/tileoperations.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./src/main.ts");
/******/ 	__webpack_require__("./src/app.ts");
/******/ 	__webpack_require__("./src/mapTile.ts");
/******/ 	__webpack_require__("./src/imgTile.ts");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/tileoperations.ts");
/******/ 	
/******/ })()
;